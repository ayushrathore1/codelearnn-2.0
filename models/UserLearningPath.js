const mongoose = require("mongoose");

/**
 * UserLearningPath Schema - User-specific learning paths
 *
 * This is separate from the system LearningPath model which contains
 * curated/official paths. UserLearningPath is for:
 * - Auto-generated paths (when user saves first video)
 * - Custom paths created by users
 * - Edited copies of official paths
 *
 * Features:
 * - Graph-based structure (nodes + edges) for non-linear paths
 * - Career association for focused learning
 * - Readiness score tracking
 * - Visibility controls (private/public)
 * - Soft delete support
 */

const nodeSchema = new mongoose.Schema(
  {
    id: {
      type: String,
      required: true,
    },
    videoId: {
      type: String, // YouTube video ID (reference to SavedVideo)
      required: true,
    },
    title: {
      type: String,
      required: true,
    },
    order: {
      type: Number,
      default: 0,
    },
    isCompleted: {
      type: Boolean,
      default: false,
    },
    completedAt: {
      type: Date,
    },
    // Optional notes/annotations
    notes: {
      type: String,
      maxlength: 1000,
    },
  },
  { _id: false },
);

const edgeSchema = new mongoose.Schema(
  {
    from: {
      type: String, // Node ID
      required: true,
    },
    to: {
      type: String, // Node ID
      required: true,
    },
    type: {
      type: String,
      enum: ["prerequisite", "optional"],
      default: "prerequisite",
    },
  },
  { _id: false },
);

const userLearningPathSchema = new mongoose.Schema(
  {
    // Owner
    userId: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "User",
      required: true,
      index: true,
    },

    // Career association (from CareerDomain collection)
    careerId: {
      type: String,
      index: true,
    },

    // Path metadata
    title: {
      type: String,
      required: true,
      trim: true,
      maxlength: 200,
    },
    description: {
      type: String,
      trim: true,
      maxlength: 1000,
    },

    // Path type
    isAutoGenerated: {
      type: Boolean,
      default: false,
    },

    // Origin tracking (if based on official path)
    basedOnPathId: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "LearningPath",
      default: null,
    },

    // Status
    status: {
      type: String,
      enum: ["draft", "active", "completed", "archived"],
      default: "draft",
      index: true,
    },

    // Graph-based structure for non-linear paths
    structureGraph: {
      nodes: [nodeSchema],
      edges: [edgeSchema],
    },

    // AI-inferred metadata
    inferredSkills: [
      {
        type: String,
        trim: true,
        lowercase: true,
      },
    ],
    inferredCareers: [
      {
        type: String,
        trim: true,
      },
    ],

    // Progress tracking
    completedNodesCount: {
      type: Number,
      default: 0,
    },
    totalNodesCount: {
      type: Number,
      default: 0,
    },

    // Career readiness (0-100)
    readinessScore: {
      type: Number,
      min: 0,
      max: 100,
      default: 0,
    },

    // Visibility
    visibility: {
      type: String,
      enum: ["private", "public"],
      default: "private",
      index: true,
    },

    // Public slug (for shareable paths)
    publicSlug: {
      type: String,
      unique: true,
      sparse: true,
    },

    // Soft delete
    deletedAt: {
      type: Date,
      default: null,
    },
  },
  {
    timestamps: true,
  },
);

// Indexes
userLearningPathSchema.index({ userId: 1, status: 1 });
userLearningPathSchema.index({ userId: 1, careerId: 1 });
userLearningPathSchema.index({ userId: 1, deletedAt: 1 });
userLearningPathSchema.index({ visibility: 1, publicSlug: 1 });

/**
 * Virtual: Progress percentage
 */
userLearningPathSchema.virtual("progressPercentage").get(function () {
  if (this.totalNodesCount === 0) return 0;
  return Math.round((this.completedNodesCount / this.totalNodesCount) * 100);
});

/**
 * Pre-save: Update node counts
 */
userLearningPathSchema.pre("save", function () {
  this.totalNodesCount = this.structureGraph?.nodes?.length || 0;
  this.completedNodesCount =
    this.structureGraph?.nodes?.filter((n) => n.isCompleted)?.length || 0;
});

/**
 * Instance method: Create a version snapshot of current state
 * Call this before making significant changes
 */
userLearningPathSchema.methods.createVersionSnapshot = async function (
  reason,
  changeDescription = null,
) {
  // Lazy load to avoid circular dependency
  const LearningPathVersion = require("./LearningPathVersion");

  return LearningPathVersion.createVersion(
    this._id,
    this.userId,
    reason,
    {
      title: this.title,
      description: this.description,
      careerId: this.careerId,
      status: this.status,
      structureGraph: JSON.parse(JSON.stringify(this.structureGraph)), // Deep clone
      inferredSkills: [...this.inferredSkills],
      inferredCareers: [...this.inferredCareers],
      readinessScore: this.readinessScore,
      visibility: this.visibility,
    },
    { changeDescription },
  );
};

/**
 * Static: Get user's active/draft paths
 */
userLearningPathSchema.statics.getUserPaths = async function (
  userId,
  options = {},
) {
  const {
    status = null,
    careerId = null,
    limit = 20,
    includeDeleted = false,
  } = options;

  const filter = { userId };

  if (!includeDeleted) {
    filter.deletedAt = null;
  }

  if (status) {
    filter.status = status;
  }

  if (careerId) {
    filter.careerId = careerId;
  }

  return this.find(filter)
    .sort({ updatedAt: -1 })
    .limit(limit)
    .select("-structureGraph.nodes.notes"); // Exclude notes for list view
};

/**
 * Static: Get user's active path
 */
userLearningPathSchema.statics.getActivePath = async function (userId) {
  return this.findOne({
    userId,
    status: "active",
    deletedAt: null,
  });
};

/**
 * Static: Create auto-generated path
 */
userLearningPathSchema.statics.createAutoPath = async function (
  userId,
  careerId,
  firstVideo,
) {
  const careerName = careerId || "Learning";

  return this.create({
    userId,
    careerId,
    title: `My ${careerName} Path`,
    description: "Auto-generated learning path based on saved videos",
    isAutoGenerated: true,
    status: "draft",
    structureGraph: {
      nodes: [
        {
          id: `node_${Date.now()}`,
          videoId: firstVideo.videoId,
          title: firstVideo.title,
          order: 0,
          isCompleted: false,
        },
      ],
      edges: [],
    },
    inferredCareers: careerId ? [careerId] : [],
    inferredSkills: firstVideo.inferredSkills || [],
  });
};

/**
 * Static: Add video to path
 */
userLearningPathSchema.statics.addVideoToPath = async function (
  pathId,
  video,
  previousNodeId = null,
) {
  const path = await this.findById(pathId);
  if (!path) throw new Error("Path not found");

  const newNodeId = `node_${Date.now()}`;
  const newNode = {
    id: newNodeId,
    videoId: video.videoId,
    title: video.title,
    order: path.structureGraph.nodes.length,
    isCompleted: false,
  };

  path.structureGraph.nodes.push(newNode);

  // Add edge if previous node specified (linear progression)
  if (previousNodeId) {
    path.structureGraph.edges.push({
      from: previousNodeId,
      to: newNodeId,
      type: "prerequisite",
    });
  } else if (path.structureGraph.nodes.length > 1) {
    // Default: connect to last node
    const lastNode =
      path.structureGraph.nodes[path.structureGraph.nodes.length - 2];
    path.structureGraph.edges.push({
      from: lastNode.id,
      to: newNodeId,
      type: "prerequisite",
    });
  }

  // Update inferred skills
  if (video.inferredSkills) {
    const existingSkills = new Set(path.inferredSkills);
    video.inferredSkills.forEach((skill) => existingSkills.add(skill));
    path.inferredSkills = Array.from(existingSkills);
  }

  await path.save();
  return path;
};

/**
 * Static: Mark node as complete
 */
userLearningPathSchema.statics.completeNode = async function (pathId, nodeId) {
  const path = await this.findById(pathId);
  if (!path) throw new Error("Path not found");

  const node = path.structureGraph.nodes.find((n) => n.id === nodeId);
  if (!node) throw new Error("Node not found");

  node.isCompleted = true;
  node.completedAt = new Date();

  // Check if all nodes are complete
  const allComplete = path.structureGraph.nodes.every((n) => n.isCompleted);
  if (allComplete) {
    path.status = "completed";
  }

  await path.save();
  return path;
};

/**
 * Static: Soft delete path
 */
userLearningPathSchema.statics.softDelete = async function (pathId, userId) {
  return this.findOneAndUpdate(
    { _id: pathId, userId },
    {
      $set: {
        deletedAt: new Date(),
        status: "archived",
      },
    },
    { new: true },
  );
};

/**
 * Static: Activate path (set as user's active path)
 */
userLearningPathSchema.statics.activatePath = async function (pathId, userId) {
  // First, deactivate any currently active path
  await this.updateMany(
    { userId, status: "active" },
    { $set: { status: "draft" } },
  );

  // Then activate the requested path
  return this.findOneAndUpdate(
    { _id: pathId, userId, deletedAt: null },
    { $set: { status: "active" } },
    { new: true },
  );
};

// ============================================
// Graph Structure Methods for Non-Linear Paths
// ============================================

/**
 * Instance method: Get nodes that can be started next
 * Returns nodes whose prerequisites are all completed
 */
userLearningPathSchema.methods.getNextAvailableNodes = function () {
  const nodes = this.structureGraph.nodes;
  const edges = this.structureGraph.edges;

  return nodes.filter((node) => {
    // Skip completed nodes
    if (node.isCompleted) return false;

    // Find prerequisite edges pointing TO this node
    const prerequisites = edges.filter(
      (e) => e.to === node.id && e.type === "prerequisite",
    );

    // If no prerequisites, it's available
    if (prerequisites.length === 0) {
      // But check if it's the first node or all previous in order are done
      const lowerOrderNodes = nodes.filter(
        (n) => n.order < node.order && !n.isCompleted,
      );
      return lowerOrderNodes.length === 0;
    }

    // Check if all prerequisite nodes are completed
    return prerequisites.every((prereq) => {
      const prereqNode = nodes.find((n) => n.id === prereq.from);
      return prereqNode?.isCompleted;
    });
  });
};

/**
 * Instance method: Check if path has branching (non-linear structure)
 */
userLearningPathSchema.methods.hasBranching = function () {
  const edges = this.structureGraph.edges;
  const nodes = this.structureGraph.nodes;

  // Check for multiple outgoing edges from any node
  const outgoingCounts = {};
  edges.forEach((edge) => {
    outgoingCounts[edge.from] = (outgoingCounts[edge.from] || 0) + 1;
  });

  // Check for multiple incoming edges to any node
  const incomingCounts = {};
  edges.forEach((edge) => {
    incomingCounts[edge.to] = (incomingCounts[edge.to] || 0) + 1;
  });

  // Has branching if any node has multiple outgoing OR multiple incoming
  const hasMultipleOutgoing = Object.values(outgoingCounts).some((c) => c > 1);
  const hasMultipleIncoming = Object.values(incomingCounts).some((c) => c > 1);

  return hasMultipleOutgoing || hasMultipleIncoming;
};

/**
 * Instance method: Get the graph structure as adjacency list
 */
userLearningPathSchema.methods.getAdjacencyList = function () {
  const adjacency = {};

  // Initialize all nodes
  this.structureGraph.nodes.forEach((node) => {
    adjacency[node.id] = { outgoing: [], incoming: [] };
  });

  // Populate edges
  this.structureGraph.edges.forEach((edge) => {
    if (adjacency[edge.from]) {
      adjacency[edge.from].outgoing.push({ to: edge.to, type: edge.type });
    }
    if (adjacency[edge.to]) {
      adjacency[edge.to].incoming.push({ from: edge.from, type: edge.type });
    }
  });

  return adjacency;
};

/**
 * Static: Create a branch from an existing node
 */
userLearningPathSchema.statics.createBranch = async function (
  pathId,
  fromNodeId,
  video,
  edgeType = "optional",
) {
  const path = await this.findById(pathId);
  if (!path) throw new Error("Path not found");

  const fromNode = path.structureGraph.nodes.find((n) => n.id === fromNodeId);
  if (!fromNode) throw new Error("Source node not found");

  const newNodeId = `node_${Date.now()}`;
  const newNode = {
    id: newNodeId,
    videoId: video.videoId,
    title: video.title,
    order: fromNode.order + 0.5, // Insert between for visual ordering
    isCompleted: false,
  };

  path.structureGraph.nodes.push(newNode);
  path.structureGraph.edges.push({
    from: fromNodeId,
    to: newNodeId,
    type: edgeType,
  });

  await path.save();
  return { path, newNodeId };
};

/**
 * Static: Remove a node and its edges
 */
userLearningPathSchema.statics.removeNode = async function (
  pathId,
  nodeId,
  userId,
) {
  const path = await this.findOne({ _id: pathId, userId, deletedAt: null });
  if (!path) throw new Error("Path not found");

  // Find the node
  const nodeIndex = path.structureGraph.nodes.findIndex((n) => n.id === nodeId);
  if (nodeIndex === -1) throw new Error("Node not found");

  // Get incoming and outgoing edges for this node
  const incomingEdges = path.structureGraph.edges.filter(
    (e) => e.to === nodeId,
  );
  const outgoingEdges = path.structureGraph.edges.filter(
    (e) => e.from === nodeId,
  );

  // Remove the node
  path.structureGraph.nodes.splice(nodeIndex, 1);

  // Remove all edges involving this node
  path.structureGraph.edges = path.structureGraph.edges.filter(
    (e) => e.from !== nodeId && e.to !== nodeId,
  );

  // Reconnect: bridge incoming to outgoing (maintain chain)
  // Only for linear paths - for branching, just remove
  if (incomingEdges.length === 1 && outgoingEdges.length === 1) {
    path.structureGraph.edges.push({
      from: incomingEdges[0].from,
      to: outgoingEdges[0].to,
      type: "prerequisite",
    });
  }

  // Re-order remaining nodes
  path.structureGraph.nodes.forEach((node, idx) => {
    node.order = idx;
  });

  await path.save();
  return path;
};

/**
 * Static: Add optional edge between existing nodes
 */
userLearningPathSchema.statics.addOptionalEdge = async function (
  pathId,
  fromNodeId,
  toNodeId,
) {
  const path = await this.findById(pathId);
  if (!path) throw new Error("Path not found");

  // Validate both nodes exist
  const fromNode = path.structureGraph.nodes.find((n) => n.id === fromNodeId);
  const toNode = path.structureGraph.nodes.find((n) => n.id === toNodeId);

  if (!fromNode || !toNode) throw new Error("One or both nodes not found");

  // Check if edge already exists
  const existingEdge = path.structureGraph.edges.find(
    (e) => e.from === fromNodeId && e.to === toNodeId,
  );

  if (existingEdge) {
    throw new Error("Edge already exists");
  }

  path.structureGraph.edges.push({
    from: fromNodeId,
    to: toNodeId,
    type: "optional",
  });

  await path.save();
  return path;
};

/**
 * Static: Remove an edge between nodes
 */
userLearningPathSchema.statics.removeEdge = async function (
  pathId,
  fromNodeId,
  toNodeId,
) {
  const path = await this.findById(pathId);
  if (!path) throw new Error("Path not found");

  const edgeIndex = path.structureGraph.edges.findIndex(
    (e) => e.from === fromNodeId && e.to === toNodeId,
  );

  if (edgeIndex === -1) throw new Error("Edge not found");

  path.structureGraph.edges.splice(edgeIndex, 1);
  await path.save();
  return path;
};

// Ensure virtuals are included in JSON
userLearningPathSchema.set("toJSON", { virtuals: true });
userLearningPathSchema.set("toObject", { virtuals: true });

const UserLearningPath = mongoose.model(
  "UserLearningPath",
  userLearningPathSchema,
);

module.exports = UserLearningPath;
