const express = require('express');
const router = express.Router();
const { protect } = require('../middleware/auth');
const UserLearningPath = require('../models/UserLearningPath');
const SavedVideo = require('../models/SavedVideo');
const User = require('../models/User');

/**
 * @route   GET /api/user/learning-paths
 * @desc    Get user's learning paths
 * @access  Private
 */
router.get('/', protect, async (req, res) => {
  try {
    const { status, careerId, limit = 20 } = req.query;
    
    const paths = await UserLearningPath.getUserPaths(req.user.id, {
      status,
      careerId,
      limit: parseInt(limit)
    });

    res.json({
      success: true,
      count: paths.length,
      data: paths
    });
  } catch (error) {
    console.error('Get user paths error:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to fetch learning paths'
    });
  }
});

/**
 * @route   GET /api/user/learning-paths/active
 * @desc    Get user's active learning path
 * @access  Private
 */
router.get('/active', protect, async (req, res) => {
  try {
    const activePath = await UserLearningPath.getActivePath(req.user.id);

    if (!activePath) {
      return res.json({
        success: true,
        data: null,
        message: 'No active learning path'
      });
    }

    res.json({
      success: true,
      data: activePath
    });
  } catch (error) {
    console.error('Get active path error:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to fetch active path'
    });
  }
});

/**
 * @route   GET /api/user/learning-paths/:id
 * @desc    Get a specific learning path
 * @access  Private
 */
router.get('/:id', protect, async (req, res) => {
  try {
    const path = await UserLearningPath.findOne({
      _id: req.params.id,
      userId: req.user.id,
      deletedAt: null
    });

    if (!path) {
      return res.status(404).json({
        success: false,
        message: 'Learning path not found'
      });
    }

    res.json({
      success: true,
      data: path
    });
  } catch (error) {
    console.error('Get path error:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to fetch learning path'
    });
  }
});

/**
 * @route   POST /api/user/learning-paths
 * @desc    Create a new learning path
 * @access  Private
 */
router.post('/', protect, async (req, res) => {
  try {
    const { title, description, careerId, videoIds = [] } = req.body;

    if (!title) {
      return res.status(400).json({
        success: false,
        message: 'Title is required'
      });
    }

    // Get user's active career if not specified
    const user = await User.findById(req.user.id);
    const pathCareerId = careerId || user.activeCareerId;

    // Create initial nodes from video IDs
    const nodes = [];
    const edges = [];

    if (videoIds.length > 0) {
      // Fetch saved videos
      const savedVideos = await SavedVideo.find({
        userId: req.user.id,
        videoId: { $in: videoIds },
        deletedAt: null
      });

      savedVideos.forEach((video, index) => {
        const nodeId = `node_${Date.now()}_${index}`;
        nodes.push({
          id: nodeId,
          videoId: video.videoId,
          title: video.title,
          order: index,
          isCompleted: false
        });

        // Create linear edge to previous node
        if (index > 0) {
          edges.push({
            from: nodes[index - 1].id,
            to: nodeId,
            type: 'prerequisite'
          });
        }
      });
    }

    const path = await UserLearningPath.create({
      userId: req.user.id,
      careerId: pathCareerId,
      title,
      description,
      isAutoGenerated: false,
      status: 'draft',
      structureGraph: { nodes, edges }
    });

    // Update saved videos to reference this path
    if (videoIds.length > 0) {
      await SavedVideo.updateMany(
        { userId: req.user.id, videoId: { $in: videoIds } },
        { $set: { addedToPathId: path._id, pathStatus: 'in_path' } }
      );
    }

    res.status(201).json({
      success: true,
      message: 'Learning path created',
      data: path
    });
  } catch (error) {
    console.error('Create path error:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to create learning path'
    });
  }
});

/**
 * @route   PUT /api/user/learning-paths/:id
 * @desc    Update a learning path
 * @access  Private
 */
router.put('/:id', protect, async (req, res) => {
  try {
    const { title, description, careerId, visibility } = req.body;

    const path = await UserLearningPath.findOne({
      _id: req.params.id,
      userId: req.user.id,
      deletedAt: null
    });

    if (!path) {
      return res.status(404).json({
        success: false,
        message: 'Learning path not found'
      });
    }

    // Update allowed fields
    if (title) path.title = title;
    if (description !== undefined) path.description = description;
    if (careerId !== undefined) path.careerId = careerId;
    if (visibility) path.visibility = visibility;

    await path.save();

    res.json({
      success: true,
      message: 'Learning path updated',
      data: path
    });
  } catch (error) {
    console.error('Update path error:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to update learning path'
    });
  }
});

/**
 * @route   PUT /api/user/learning-paths/:id/activate
 * @desc    Set a path as the active learning path
 * @access  Private
 */
router.put('/:id/activate', protect, async (req, res) => {
  try {
    const path = await UserLearningPath.activatePath(req.params.id, req.user.id);

    if (!path) {
      return res.status(404).json({
        success: false,
        message: 'Learning path not found'
      });
    }

    // Update user's active learning path
    await User.findByIdAndUpdate(req.user.id, {
      activeLearningPathId: path._id
    });

    res.json({
      success: true,
      message: 'Learning path activated',
      data: path
    });
  } catch (error) {
    console.error('Activate path error:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to activate learning path'
    });
  }
});

/**
 * @route   POST /api/user/learning-paths/:id/add-video
 * @desc    Add a video to a learning path
 * @access  Private
 */
router.post('/:id/add-video', protect, async (req, res) => {
  try {
    const { videoId, previousNodeId } = req.body;

    if (!videoId) {
      return res.status(400).json({
        success: false,
        message: 'videoId is required'
      });
    }

    // Get saved video
    const savedVideo = await SavedVideo.findOne({
      userId: req.user.id,
      videoId,
      deletedAt: null
    });

    if (!savedVideo) {
      return res.status(404).json({
        success: false,
        message: 'Saved video not found. Save the video first.'
      });
    }

    // Add to path
    const path = await UserLearningPath.addVideoToPath(
      req.params.id,
      savedVideo,
      previousNodeId
    );

    // Update saved video association
    savedVideo.addedToPathId = path._id;
    savedVideo.pathStatus = 'in_path';
    await savedVideo.save();

    res.json({
      success: true,
      message: 'Video added to path',
      data: path
    });
  } catch (error) {
    console.error('Add video to path error:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to add video to path'
    });
  }
});

/**
 * @route   PUT /api/user/learning-paths/:id/reorder
 * @desc    Reorder nodes in a learning path
 * @access  Private
 */
router.put('/:id/reorder', protect, async (req, res) => {
  try {
    const { nodeOrder } = req.body; // Array of node IDs in new order

    if (!nodeOrder || !Array.isArray(nodeOrder)) {
      return res.status(400).json({
        success: false,
        message: 'nodeOrder array is required'
      });
    }

    const path = await UserLearningPath.findOne({
      _id: req.params.id,
      userId: req.user.id,
      deletedAt: null
    });

    if (!path) {
      return res.status(404).json({
        success: false,
        message: 'Learning path not found'
      });
    }

    // Reorder nodes
    const nodeMap = new Map(path.structureGraph.nodes.map(n => [n.id, n]));
    path.structureGraph.nodes = nodeOrder.map((id, index) => {
      const node = nodeMap.get(id);
      if (node) {
        node.order = index;
        return node;
      }
      return null;
    }).filter(Boolean);

    // Rebuild linear edges
    path.structureGraph.edges = [];
    for (let i = 0; i < path.structureGraph.nodes.length - 1; i++) {
      path.structureGraph.edges.push({
        from: path.structureGraph.nodes[i].id,
        to: path.structureGraph.nodes[i + 1].id,
        type: 'prerequisite'
      });
    }

    await path.save();

    res.json({
      success: true,
      message: 'Path reordered',
      data: path
    });
  } catch (error) {
    console.error('Reorder path error:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to reorder path'
    });
  }
});

/**
 * @route   PUT /api/user/learning-paths/:id/complete-node/:nodeId
 * @desc    Mark a node as complete
 * @access  Private
 */
router.put('/:id/complete-node/:nodeId', protect, async (req, res) => {
  try {
    // Verify ownership
    const ownerCheck = await UserLearningPath.findOne({
      _id: req.params.id,
      userId: req.user.id,
      deletedAt: null
    });

    if (!ownerCheck) {
      return res.status(404).json({
        success: false,
        message: 'Learning path not found'
      });
    }

    const path = await UserLearningPath.completeNode(req.params.id, req.params.nodeId);

    // Also update the saved video
    const node = path.structureGraph.nodes.find(n => n.id === req.params.nodeId);
    if (node) {
      await SavedVideo.findOneAndUpdate(
        { userId: req.user.id, videoId: node.videoId },
        { $set: { isCompleted: true, completedAt: new Date() } }
      );
    }

    res.json({
      success: true,
      message: 'Node marked as complete',
      data: path
    });
  } catch (error) {
    console.error('Complete node error:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to complete node'
    });
  }
});

/**
 * @route   DELETE /api/user/learning-paths/:id
 * @desc    Delete a learning path (soft delete)
 * @access  Private
 */
router.delete('/:id', protect, async (req, res) => {
  try {
    const path = await UserLearningPath.softDelete(req.params.id, req.user.id);

    if (!path) {
      return res.status(404).json({
        success: false,
        message: 'Learning path not found'
      });
    }

    // If this was the user's active path, clear it
    const user = await User.findById(req.user.id);
    if (user.activeLearningPathId?.toString() === req.params.id) {
      user.activeLearningPathId = null;
      await user.save();
    }

    // Clear path association from saved videos
    await SavedVideo.updateMany(
      { addedToPathId: path._id },
      { $set: { addedToPathId: null, pathStatus: 'not_added' } }
    );

    res.json({
      success: true,
      message: 'Learning path deleted',
      data: path
    });
  } catch (error) {
    console.error('Delete path error:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to delete learning path'
    });
  }
});

// ============================================
// Branching & Graph Structure Routes
// ============================================

/**
 * @route   DELETE /api/user/learning-paths/:id/remove-node/:nodeId
 * @desc    Remove a node from the path (keeps video in library)
 * @access  Private
 */
router.delete('/:id/remove-node/:nodeId', protect, async (req, res) => {
  try {
    const path = await UserLearningPath.removeNode(
      req.params.id,
      req.params.nodeId,
      req.user.id
    );

    res.json({
      success: true,
      message: 'Node removed from path',
      data: path
    });
  } catch (error) {
    console.error('Remove node error:', error);
    res.status(500).json({
      success: false,
      message: error.message || 'Failed to remove node'
    });
  }
});

/**
 * @route   POST /api/user/learning-paths/:id/create-branch
 * @desc    Create a branch from an existing node (for non-linear paths)
 * @access  Private
 */
router.post('/:id/create-branch', protect, async (req, res) => {
  try {
    const { fromNodeId, videoId, edgeType = 'optional' } = req.body;

    if (!fromNodeId || !videoId) {
      return res.status(400).json({
        success: false,
        message: 'fromNodeId and videoId are required'
      });
    }

    // Verify ownership
    const ownerCheck = await UserLearningPath.findOne({
      _id: req.params.id,
      userId: req.user.id,
      deletedAt: null
    });

    if (!ownerCheck) {
      return res.status(404).json({
        success: false,
        message: 'Learning path not found'
      });
    }

    // Get saved video
    const savedVideo = await SavedVideo.findOne({
      userId: req.user.id,
      videoId,
      deletedAt: null
    });

    if (!savedVideo) {
      return res.status(404).json({
        success: false,
        message: 'Saved video not found'
      });
    }

    const { path, newNodeId } = await UserLearningPath.createBranch(
      req.params.id,
      fromNodeId,
      savedVideo,
      edgeType
    );

    // Update saved video association
    savedVideo.addedToPathId = path._id;
    savedVideo.pathStatus = 'in_path';
    await savedVideo.save();

    res.json({
      success: true,
      message: 'Branch created',
      data: { path, newNodeId }
    });
  } catch (error) {
    console.error('Create branch error:', error);
    res.status(500).json({
      success: false,
      message: error.message || 'Failed to create branch'
    });
  }
});

/**
 * @route   POST /api/user/learning-paths/:id/add-edge
 * @desc    Add an optional edge between existing nodes
 * @access  Private
 */
router.post('/:id/add-edge', protect, async (req, res) => {
  try {
    const { fromNodeId, toNodeId } = req.body;

    if (!fromNodeId || !toNodeId) {
      return res.status(400).json({
        success: false,
        message: 'fromNodeId and toNodeId are required'
      });
    }

    // Verify ownership
    const ownerCheck = await UserLearningPath.findOne({
      _id: req.params.id,
      userId: req.user.id,
      deletedAt: null
    });

    if (!ownerCheck) {
      return res.status(404).json({
        success: false,
        message: 'Learning path not found'
      });
    }

    const path = await UserLearningPath.addOptionalEdge(
      req.params.id,
      fromNodeId,
      toNodeId
    );

    res.json({
      success: true,
      message: 'Edge added',
      data: path
    });
  } catch (error) {
    console.error('Add edge error:', error);
    res.status(500).json({
      success: false,
      message: error.message || 'Failed to add edge'
    });
  }
});

/**
 * @route   DELETE /api/user/learning-paths/:id/remove-edge
 * @desc    Remove an edge between nodes
 * @access  Private
 */
router.delete('/:id/remove-edge', protect, async (req, res) => {
  try {
    const { fromNodeId, toNodeId } = req.body;

    if (!fromNodeId || !toNodeId) {
      return res.status(400).json({
        success: false,
        message: 'fromNodeId and toNodeId are required'
      });
    }

    // Verify ownership
    const ownerCheck = await UserLearningPath.findOne({
      _id: req.params.id,
      userId: req.user.id,
      deletedAt: null
    });

    if (!ownerCheck) {
      return res.status(404).json({
        success: false,
        message: 'Learning path not found'
      });
    }

    const path = await UserLearningPath.removeEdge(
      req.params.id,
      fromNodeId,
      toNodeId
    );

    res.json({
      success: true,
      message: 'Edge removed',
      data: path
    });
  } catch (error) {
    console.error('Remove edge error:', error);
    res.status(500).json({
      success: false,
      message: error.message || 'Failed to remove edge'
    });
  }
});

/**
 * @route   GET /api/user/learning-paths/:id/next-available
 * @desc    Get nodes that can be started next (prerequisites completed)
 * @access  Private
 */
router.get('/:id/next-available', protect, async (req, res) => {
  try {
    const path = await UserLearningPath.findOne({
      _id: req.params.id,
      userId: req.user.id,
      deletedAt: null
    });

    if (!path) {
      return res.status(404).json({
        success: false,
        message: 'Learning path not found'
      });
    }

    const availableNodes = path.getNextAvailableNodes();

    res.json({
      success: true,
      count: availableNodes.length,
      data: availableNodes
    });
  } catch (error) {
    console.error('Get next available error:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to get available nodes'
    });
  }
});

/**
 * @route   GET /api/user/learning-paths/:id/has-branching
 * @desc    Check if a path has non-linear structure
 * @access  Private
 */
router.get('/:id/has-branching', protect, async (req, res) => {
  try {
    const path = await UserLearningPath.findOne({
      _id: req.params.id,
      userId: req.user.id,
      deletedAt: null
    });

    if (!path) {
      return res.status(404).json({
        success: false,
        message: 'Learning path not found'
      });
    }

    const hasBranching = path.hasBranching();

    res.json({
      success: true,
      data: { hasBranching }
    });
  } catch (error) {
    console.error('Check branching error:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to check branching'
    });
  }
});

// ============================================
// Visibility & Sharing Routes
// ============================================

/**
 * @route   PUT /api/user/learning-paths/:id/visibility
 * @desc    Toggle path visibility (private/public)
 * @access  Private
 */
router.put('/:id/visibility', protect, async (req, res) => {
  try {
    const { visibility } = req.body;

    if (!['private', 'public'].includes(visibility)) {
      return res.status(400).json({
        success: false,
        message: 'Visibility must be "private" or "public"'
      });
    }

    const path = await UserLearningPath.findOne({
      _id: req.params.id,
      userId: req.user.id,
      deletedAt: null
    });

    if (!path) {
      return res.status(404).json({
        success: false,
        message: 'Learning path not found'
      });
    }

    // Update visibility
    path.visibility = visibility;

    // Generate public slug if making public
    if (visibility === 'public' && !path.publicSlug) {
      const slugBase = path.title
        .toLowerCase()
        .replace(/[^a-z0-9]+/g, '-')
        .replace(/^-+|-+$/g, '');
      path.publicSlug = `${slugBase}-${Date.now().toString(36)}`;
    }

    await path.save();

    res.json({
      success: true,
      message: `Path is now ${visibility}`,
      data: {
        visibility: path.visibility,
        publicSlug: path.publicSlug,
        shareUrl: path.visibility === 'public' 
          ? `/paths/${path.publicSlug}` 
          : null
      }
    });
  } catch (error) {
    console.error('Toggle visibility error:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to update visibility'
    });
  }
});

/**
 * @route   GET /api/user/learning-paths/public
 * @desc    Get list of public learning paths (browse)
 * @access  Public
 */
router.get('/public/browse', async (req, res) => {
  try {
    const { limit = 20, offset = 0, careerId } = req.query;

    const filter = {
      visibility: 'public',
      deletedAt: null,
      'structureGraph.nodes.0': { $exists: true } // Has at least one node
    };

    if (careerId) {
      filter.careerId = careerId;
    }

    const paths = await UserLearningPath.find(filter)
      .sort({ createdAt: -1 })
      .skip(parseInt(offset))
      .limit(parseInt(limit))
      .select('title description careerId publicSlug totalNodesCount completedNodesCount createdAt userId')
      .populate('userId', 'name');

    const total = await UserLearningPath.countDocuments(filter);

    res.json({
      success: true,
      count: paths.length,
      total,
      data: paths.map(p => ({
        ...p.toObject(),
        shareUrl: `/paths/${p.publicSlug}`,
        authorName: p.userId?.name || 'Anonymous'
      }))
    });
  } catch (error) {
    console.error('Get public paths error:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to fetch public paths'
    });
  }
});

/**
 * @route   GET /api/user/learning-paths/public/:slug
 * @desc    Get a public path by slug
 * @access  Public
 */
router.get('/public/:slug', async (req, res) => {
  try {
    const path = await UserLearningPath.findOne({
      publicSlug: req.params.slug,
      visibility: 'public',
      deletedAt: null
    })
      .select('-deletedAt')
      .populate('userId', 'name');

    if (!path) {
      return res.status(404).json({
        success: false,
        message: 'Path not found or is private'
      });
    }

    res.json({
      success: true,
      data: {
        ...path.toObject(),
        authorName: path.userId?.name || 'Anonymous',
        userId: undefined // Don't expose userId
      }
    });
  } catch (error) {
    console.error('Get public path error:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to fetch path'
    });
  }
});

/**
 * @route   POST /api/user/learning-paths/clone/:id
 * @desc    Clone a public path to user's own paths
 * @access  Private
 */
router.post('/clone/:id', protect, async (req, res) => {
  try {
    // Find the source path (must be public or owned by user)
    const sourcePath = await UserLearningPath.findOne({
      _id: req.params.id,
      deletedAt: null,
      $or: [
        { visibility: 'public' },
        { userId: req.user.id }
      ]
    });

    if (!sourcePath) {
      return res.status(404).json({
        success: false,
        message: 'Path not found or is private'
      });
    }

    // Create a copy for the user
    const clonedPath = await UserLearningPath.create({
      userId: req.user.id,
      title: `${sourcePath.title} (Copy)`,
      description: sourcePath.description,
      careerId: sourcePath.careerId,
      isAutoGenerated: false,
      basedOnPathId: sourcePath._id,
      status: 'draft',
      structureGraph: {
        nodes: sourcePath.structureGraph.nodes.map(node => ({
          ...node,
          isCompleted: false,
          completedAt: null
        })),
        edges: [...sourcePath.structureGraph.edges]
      },
      inferredSkills: [...sourcePath.inferredSkills],
      inferredCareers: [...sourcePath.inferredCareers],
      visibility: 'private'
    });

    res.status(201).json({
      success: true,
      message: 'Path cloned successfully',
      data: clonedPath
    });
  } catch (error) {
    console.error('Clone path error:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to clone path'
    });
  }
});

module.exports = router;


